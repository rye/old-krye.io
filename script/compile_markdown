#!/usr/bin/env ruby

require 'date'
require 'uri'
require 'net/http'
require 'optparse'
require 'github/markup'

$output_dir = 'posts'
$files = []

option_parser = OptionParser.new do |parser|

	parser.banner = 'Usage: $0 [options] <filename> [ <filename> ... ]'

	parser.separator ''
	parser.separator 'Options:'

	parser.on '-o', '--output DIR', "Output compiled files into DIR. (default: #{$output_dir})" do |dir|
		$output_dir = dir
	end

	parser.on '-h', '--help', 'Print this help banner' do
		puts parser
		exit
	end

end

# Parse all arguments, try to glean what we can from them.
option_parser.parse!

# After parsing using OptionParser, leftover arguments will be in the ARGV.
#
# Since filenames are simply extra arguments, we should make sure that
# extra arguments were given (and thus are left over in ARGV)
if ARGV.count == 0

	puts option_parser
	exit

end

# Loop through the ARGV and take arguments in the order they appear.
while value = ARGV.shift

	# Check if the current argument value is a file and is readable.
	# If so, assume that it is a filename that we should use.
	#
	# TODO: Add logic to ensure that value also has appropriate extension
	#   e.g. using File.extname
	if File.exist? value and File.readable? value
		$files.push value
	end

end

puts "Have #{$files.count} files to handle..."

$files.each do |file|

	matched, prefix, year, month, day, basename = file.match(/^(?<prefix>.+)\/(?<year>\d{4})\/(?<month>\d{1,2})\/(?<day>\d{1,2})\/(?<filename>.+)$/).to_a

	raise RuntimeError, 'RegExp-matched portion of filename does not equal entire filename!' unless matched == file

	file_without_extension = File.basename(basename, File.extname(basename))
	post_date = Date.new(year.to_i, month.to_i, day.to_i)
	output_filename = File.join($output_dir, year, month, day, "#{file_without_extension}.html")

	data = nil

	open(file, 'rb') do |io|
		data = io.read
	end

	output_io = open(output_filename, 'wb')

	raw_markdown_uri = URI('https://api.github.com/markdown/raw')

	transport = Net::HTTP.new(raw_markdown_uri.host, raw_markdown_uri.port)
	transport.use_ssl = true

	transport.start do |_transport|

		request = Net::HTTP::Post.new(raw_markdown_uri)

		request.body = data
		request.content_type = 'text/x-markdown'

		body = ""

		_transport.request(request) do |response|
			response.read_body do |chunk|
				body << chunk
				output_io.write(chunk)
			end
		end

		puts body

	end

	output_io.close

end
